An√°lisis y Traducci√≥n de Requisitos Funcionales
Tu solicitud se desglosa en estos 4 requisitos t√©cnicos:
Enlace Autom√°tico v√≠a QR: El usuario escanea el QR y la sesi√≥n de WhatsApp se establece, quedando lista para operar.
Activaci√≥n por Disparador (Trigger): La IA solo debe responder a los mensajes que contengan una palabra o frase clave (disparador) definida en la configuraci√≥n del chatbot.
Visualizaci√≥n del N√∫mero Enlazado: La interfaz de usuario debe mostrar el n√∫mero de tel√©fono de la cuenta de WhatsApp que se acaba de conectar.
Conexi√≥n Estable: La sesi√≥n de WhatsApp no debe desconectarse f√°cilmente y debe ser resiliente.
Ahora, veamos c√≥mo implementar cada uno de estos puntos en tu c√≥digo.
Plan de Implementaci√≥n y Correcciones al C√≥digo
1. Enlace Autom√°tico v√≠a QR (¬°Esto ya lo tienes casi listo!)
Tu flujo actual en whatsappMultiService.ts y WhatsAppIntegration.tsx ya maneja esto. El usuario hace clic en "Conectar", se genera un QR, lo escanea, y la sesi√≥n se activa. Esto es correcto. El "automatismo" es inherente al funcionamiento de WhatsApp Web.
Sugerencia: Aseg√∫rate de que el estado en el frontend se actualice correctamente cuando la conexi√≥n se establece sin necesidad de recargar la p√°gina. Podr√≠as usar WebSockets o un polling m√°s frecuente en el frontend para verificar el estado despu√©s de mostrar el QR. Tu waitForConnection en el backend es un buen comienzo para esto.
2. Activaci√≥n por Disparador (MODIFICACI√ìN NECESARIA)
Actualmente, tu processIncomingMessage en whatsappMultiService.ts procesa todos los mensajes. Necesitas agregar una l√≥gica para filtrar por los disparadores. Tu schema de base de datos ya est√° preparado para esto con el campo triggerKeywords.
Acci√≥n: Modifica la funci√≥n processIncomingMessage en server/whatsappMultiService.ts.
C√≥digo Actual (Problem√°tico):
Generated typescript
// server/whatsappMultiService.ts

private async processIncomingMessage(message: any, session: WhatsAppSession, sessionKey: string) {
  try {
    const { advancedAIService } = await import('./advancedAIService.js');
    const { storage } = await import('./storage.js');
    
    console.log(`üì® Procesando mensaje de ${message.contact}: ${message.message}`);
    
    // SIEMPRE procesa el mensaje
    const context = advancedAIService.analyzeConversation(message.message);
    // ... el resto de la l√≥gica
Use code with caution.
TypeScript
C√≥digo Corregido (Con L√≥gica de Disparador):
Generated typescript
// server/whatsappMultiService.ts

private async processIncomingMessage(message: any, session: WhatsAppSession, sessionKey: string) {
  try {
    const { advancedAIService } = await import('./advancedAIService.js');
    const { storage } = await import('./storage.js');
    
    const chatbotId = parseInt(session.chatbotId);
    
    // 1. Obtener los detalles del chatbot, incluyendo los disparadores
    const chatbot = await storage.getChatbot(chatbotId);
    if (!chatbot) {
      console.error(`Chatbot con ID ${chatbotId} no encontrado.`);
      return;
    }

    // 2. Verificar si hay disparadores configurados y si el mensaje los contiene
    const triggers: string[] = chatbot.triggerKeywords || [];
    const incomingMessage = message.message.toLowerCase();

    // Si no hay triggers, responde a todo. Si hay, verifica si el mensaje contiene alguno.
    const shouldRespond = triggers.length === 0 || triggers.some(trigger => incomingMessage.includes(trigger.toLowerCase()));

    if (!shouldRespond) {
      console.log(`üí¨ Mensaje de ${message.contact} ignorado (no contiene disparador).`);
      return; // No hacer nada si no hay un disparador
    }

    console.log(`üì® Procesando mensaje de ${message.contact} (disparador encontrado): ${message.message}`);
    
    // 3. Si el disparador est√° presente, continuar con la l√≥gica de la IA
    const context = advancedAIService.analyzeConversation(message.message);
    const aiResponse = await advancedAIService.generateIntelligentResponse(
      context, 
      session.userId, 
      chatbotId
    );

    await storage.saveWhatsAppMessage({
      chatbotId: chatbotId,
      contactPhone: message.contact,
      contactName: message.contact,
      messageType: 'incoming',
      content: message.message,
      detectedIntent: context.detectedIntent,
      sentimentScore: context.sentimentScore.toString(),
      aiResponse: aiResponse.message
    });

    await this.sendMessage(session, message.contact, aiResponse.message);
    
    console.log(`‚úÖ Respuesta enviada a ${message.contact}: ${aiResponse.message}`);
    
  } catch (error) {
    console.error('‚ùå Error processing message:', error);
  }
}
Use code with caution.
TypeScript
3. Visualizaci√≥n del N√∫mero Enlazado (MODIFICACI√ìN NECESARIA)
Este es el requisito m√°s complicado porque WhatsApp Web no expone f√°cilmente el n√∫mero de tel√©fono del propio usuario en el DOM. Intentar "scrapear" esta informaci√≥n de la p√°gina de perfil es muy fr√°gil y se romper√° con cualquier actualizaci√≥n de WhatsApp.
La Soluci√≥n Profesional y Robusta: Pedirle al usuario que confirme su n√∫mero.
Acci√≥n:
Backend: Tu schema (chatbots.whatsappNumber) y tu API de updateChatbot ya est√°n listos para guardar el n√∫mero. ¬°Perfecto!
Frontend: Modifica WhatsAppIntegration.tsx para a√±adir un campo donde el usuario pueda ingresar y guardar el n√∫mero de tel√©fono asociado a ese chatbot. Este campo podr√≠a aparecer una vez que la conexi√≥n est√© establecida.
Ejemplo de c√≥mo a√±adirlo en WhatsAppIntegration.tsx:
Generated tsx
// Dentro del componente WhatsAppIntegration

// ... otros estados
const [phoneNumber, setPhoneNumber] = useState('');

// ... en el useEffect que carga el estado, tambi√©n obt√©n el n√∫mero guardado
useEffect(() => {
    const fetchStatus = async () => {
        const response = await apiRequest('GET', `/api/chatbots/${chatbotId}`);
        const data = await response.json();
        // ...
        setPhoneNumber(data.whatsappNumber || ''); // Cargar el n√∫mero guardado
    }
    fetchStatus();
}, [chatbotId]);

const handleSavePhoneNumber = async () => {
    try {
        await apiRequest('PUT', `/api/chatbots/${chatbotId}`, { whatsappNumber: phoneNumber });
        toast({ title: "N√∫mero guardado", description: "El n√∫mero de WhatsApp ha sido guardado." });
    } catch (error) {
        toast({ title: "Error", description: "No se pudo guardar el n√∫mero.", variant: "destructive" });
    }
};

// ... en el JSX, dentro de CardContent cuando est√° conectado
{isConnected && (
    <div className="space-y-4">
        <div className="bg-green-50 ...">
            {/* ... Mensaje de conectado exitosamente */}
        </div>

        {/* --- NUEVA SECCI√ìN --- */}
        <div>
            <Label htmlFor="whatsapp-number">N√∫mero de WhatsApp Enlazado</Label>
            <div className="flex items-center gap-2 mt-1">
                <Input
                    id="whatsapp-number"
                    value={phoneNumber}
                    onChange={(e) => setPhoneNumber(e.target.value)}
                    placeholder="Ej: +5491122334455"
                />
                <Button onClick={handleSavePhoneNumber} size="sm">Guardar</Button>
            </div>
            <p className="text-xs text-gray-500 mt-1">
                Este n√∫mero se usa para identificaci√≥n. Aseg√∫rate que coincida con la cuenta conectada.
            </p>
        </div>
        {/* --- FIN NUEVA SECCI√ìN --- */}
    </div>
)}
Use code with caution.
Tsx
4. Conexi√≥n Estable (MEJORA CR√çTICA)
Tu sistema actual de sesiones en memoria (private sessions: Map<...) es propenso a fallos. Si el servidor se reinicia, todas las conexiones se pierden.
Acci√≥n: Debes persistir la informaci√≥n de la sesi√≥n de WhatsApp.
Persistir Sesi√≥n: La librer√≠a whatsapp-web.js (que est√°s usando indirectamente a trav√©s de Puppeteer) tiene mecanismos para guardar y restaurar sesiones, usualmente en un archivo JSON. Tu campo chatbots.whatsappSessionData en la base de datos es el lugar perfecto para esto.
Cuando Puppeteer se conecte, obtendr√° un objeto de sesi√≥n. Debes guardarlo en whatsappSessionData.
Al iniciar una conexi√≥n, primero intenta restaurarla desde whatsappSessionData. Si falla o no existe, entonces genera un nuevo QR.
Health Checks (Monitoreo de Salud): La conexi√≥n puede caerse (ej: el tel√©fono pierde internet). Necesitas un mecanismo que lo detecte.
Crea un setInterval que se ejecute cada 5-10 minutos para cada sesi√≥n activa.
Dentro del intervalo, llama a tu funci√≥n checkIfConnected.
Si checkIfConnected devuelve false, actualiza el estado del chatbot en la base de datos (whatsappConnected = false) y notifica al usuario (por email o en el dashboard) que necesita volver a conectar.
Instrucci√≥n para la IA "Corregida" (Versi√≥n Requerimiento Funcional)
Si tuvieras que escribir esto en un ticket para un desarrollador (o para ti mismo), se ver√≠a as√≠:
T√≠tulo: Implementar Conexi√≥n de Chatbot a WhatsApp con Activaci√≥n por Disparador
User Story:
Como usuario de ConversIA, quiero conectar un chatbot a mi n√∫mero de WhatsApp escaneando un c√≥digo QR. Una vez conectado, el chatbot debe permanecer en escucha y solo responder autom√°ticamente a los mensajes que contengan una de las palabras clave que he configurado como "disparador". La interfaz debe mostrarme claramente qu√© n√∫mero de tel√©fono est√° enlazado y la conexi√≥n debe ser estable, reconect√°ndose si es posible o notific√°ndome si se pierde la sesi√≥n.
Criterios de Aceptaci√≥n:
El sistema genera un c√≥digo QR para que el usuario vincule su WhatsApp.
Una vez escaneado, el estado en el UI cambia a "Conectado".
El usuario puede introducir y guardar el n√∫mero de tel√©fono asociado a la cuenta de WhatsApp conectada.
El motor de IA solo procesa y responde a mensajes entrantes si contienen un triggerKeyword definido en la configuraci√≥n del chatbot. Si no hay triggerKeywords, responde a todos los mensajes.
Los mensajes que no contienen un disparador son ignorados por la IA.
La sesi√≥n de WhatsApp se guarda en la base de datos para sobrevivir a reinicios del servidor.
Un "health check" verifica peri√≥dicamente la conexi√≥n y actualiza el estado si la sesi√≥n se pierde.