// whatsappRoutes.ts - Rutas para manejar WhatsApp
import { Router } from 'express';
import WhatsAppWebService from './whatsappWebService';
import { authenticateToken } from './auth';
import { db } from './storage';
import { chatbots, whatsappIntegrations, whatsappMessages } from '../shared/schema';
import { eq, and } from 'drizzle-orm';

const router = Router();
const whatsappService = new WhatsAppWebService();

// Mapa para almacenar conexiones SSE por usuario
const sseConnections = new Map<string, any>();

// Configurar listeners del servicio WhatsApp
whatsappService.on('qr', async ({ chatbotId, qr }) => {
  console.log(`QR generado para chatbot ${chatbotId}`);
  
  // Notificar via SSE si hay conexión activa
  const userId = await getUserFromChatbot(chatbotId);
  if (userId && sseConnections.has(userId)) {
    const res = sseConnections.get(userId);
    res.write(`data: ${JSON.stringify({ type: 'qr', chatbotId, qr })}\n\n`);
  }
});

whatsappService.on('connected', async ({ chatbotId }) => {
  console.log(`WhatsApp conectado para chatbot ${chatbotId}`);
  
  // Actualizar estado en base de datos
  await db
    .update(whatsappIntegrations)
    .set({ 
      isConnected: true, 
      lastConnected: new Date(),
      status: 'connected'
    })
    .where(eq(whatsappIntegrations.chatbotId, chatbotId));

  // Notificar via SSE
  const userId = await getUserFromChatbot(chatbotId);
  if (userId && sseConnections.has(userId)) {
    const res = sseConnections.get(userId);
    res.write(`data: ${JSON.stringify({ type: 'connected', chatbotId })}\n\n`);
  }
});

whatsappService.on('disconnected', async ({ chatbotId }) => {
  console.log(`WhatsApp desconectado para chatbot ${chatbotId}`);
  
  // Actualizar estado en base de datos
  await db
    .update(whatsappIntegrations)
    .set({ 
      isConnected: false,
      status: 'disconnected'
    })
    .where(eq(whatsappIntegrations.chatbotId, chatbotId));

  // Notificar via SSE
  const userId = await getUserFromChatbot(chatbotId);
  if (userId && sseConnections.has(userId)) {
    const res = sseConnections.get(userId);
    res.write(`data: ${JSON.stringify({ type: 'disconnected', chatbotId })}\n\n`);
  }
});

whatsappService.on('message', async (message) => {
  console.log(`Mensaje recibido para chatbot ${message.chatbotId}:`, message.body);
  
  try {
    // Guardar mensaje en base de datos
    await db.insert(whatsappMessages).values({
      id: message.id,
      chatbotId: message.chatbotId,
      fromNumber: message.from,
      toNumber: message.to,
      body: message.body,
      timestamp: message.timestamp,
      isFromMe: message.isFromMe,
      messageType: 'text'
    });

    // Procesar con IA y responder
    if (!message.isFromMe) {
      await processMessageWithAI(message);
    }

    // Notificar via SSE
    const userId = await getUserFromChatbot(message.chatbotId);
    if (userId && sseConnections.has(userId)) {
      const res = sseConnections.get(userId);
      res.write(`data: ${JSON.stringify({ type: 'message', message })}\n\n`);
    }

  } catch (error) {
    console.error('Error procesando mensaje:', error);
  }
});

// Función auxiliar para obtener userId desde chatbotId
async function getUserFromChatbot(chatbotId: string): Promise<string | null> {
  try {
    const chatbot = await db
      .select({ userId: chatbots.userId })
      .from(chatbots)
      .where(eq(chatbots.id, chatbotId))
      .limit(1);

    return chatbot[0]?.userId || null;
  } catch (error) {
    console.error('Error obteniendo userId:', error);
    return null;
  }
}

// Procesar mensaje con IA
async function processMessageWithAI(message: any) {
  try {
    // Importar servicio de IA
    const { AdvancedAIService } = await import('./advancedAIService');
    
    // Obtener configuración del chatbot
    const chatbotConfig = await db
      .select()
      .from(chatbots)
      .where(eq(chatbots.id, message.chatbotId))
      .limit(1);

    if (!chatbotConfig[0]) {
      throw new Error('Chatbot no encontrado');
    }

    const aiService = new AdvancedAIService();
    
    // Generar respuesta con IA
    const aiResponse = await aiService.generateContextualResponse(
      message.body,
      message.from,
      message.chatbotId,
      chatbotConfig[0]
    );

    if (aiResponse && aiResponse.response) {
      // Enviar respuesta via WhatsApp
      await whatsappService.sendMessage(
        message.chatbotId,
        message.from,
        aiResponse.response
      );

      // Guardar respuesta en base de datos
      await db.insert(whatsappMessages).values({
        id: `ai_${Date.now()}`,
        chatbotId: message.chatbotId,
        fromNumber: message.to,
        toNumber: message.from,
        body: aiResponse.response,
        timestamp: new Date(),
        isFromMe: true,
        messageType: 'text'
      });
    }

  } catch (error) {
    console.error('Error procesando con IA:', error);
  }
}

// Inicializar conexión WhatsApp para un chatbot
router.post('/whatsapp/connect/:chatbotId', authenticateToken, async (req, res) => {
  try {
    const { chatbotId } = req.params;
    const userId = req.user.userId;

    // Verificar que el chatbot pertenece al usuario
    const chatbot = await db
      .select()
      .from(chatbots)
      .where(and(
        eq(chatbots.id, chatbotId),
        eq(chatbots.userId, userId)
      ))
      .limit(1);

    if (!chatbot[0]) {
      return res.status(404).json({ error: 'Chatbot no encontrado' });
    }

    // Inicializar sesión WhatsApp
    const result = await whatsappService.initializeSession(chatbotId);
    
    if (result === 'CONNECTED') {
      res.json({ 
        success: true, 
        status: 'connected',
        message: 'WhatsApp ya está conectado' 
      });
    } else {
      res.json({ 
        success: true, 
        status: 'waiting_qr',
        qr: result,
        message: 'Escanea el código QR con WhatsApp' 
      });
    }

  } catch (error) {
    console.error('Error conectando WhatsApp:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Obtener estado de conexión
router.get('/whatsapp/status/:chatbotId', authenticateToken, async (req, res) => {
  try {
    const { chatbotId } = req.params;
    const userId = req.user.userId;

    // Verificar que el chatbot pertenece al usuario
    const chatbot = await db
      .select()
      .from(chatbots)
      .where(and(
        eq(chatbots.id, chatbotId),
        eq(chatbots.userId, userId)
      ))
      .limit(1);

    if (!chatbot[0]) {
      return res.status(404).json({ error: 'Chatbot no encontrado' });
    }

    const status = whatsappService.getSessionStatus(chatbotId);
    
    res.json({
      success: true,
      ...status
    });

  } catch (error) {
    console.error('Error obteniendo estado:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Desconectar WhatsApp
router.post('/whatsapp/disconnect/:chatbotId', authenticateToken, async (req, res) => {
  try {
    const { chatbotId } = req.params;
    const userId = req.user.userId;

    // Verificar que el chatbot pertenece al usuario
    const chatbot = await db
      .select()
      .from(chatbots)
      .where(and(
        eq(chatbots.id, chatbotId),
        eq(chatbots.userId, userId)
      ))
      .limit(1);

    if (!chatbot[0]) {
      return res.status(404).json({ error: 'Chatbot no encontrado' });
    }

    await whatsappService.disconnectSession(chatbotId);
    
    res.json({ 
      success: true, 
      message: 'WhatsApp desconectado correctamente' 
    });

  } catch (error) {
    console.error('Error desconectando WhatsApp:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Enviar mensaje manual
router.post('/whatsapp/send/:chatbotId', authenticateToken, async (req, res) => {
  try {
    const { chatbotId } = req.params;
    const { to, message } = req.body;
    const userId = req.user.userId;

    // Verificar que el chatbot pertenece al usuario
    const chatbot = await db
      .select()
      .from(chatbots)
      .where(and(
        eq(chatbots.id, chatbotId),
        eq(chatbots.userId, userId)
      ))
      .limit(1);

    if (!chatbot[0]) {
      return res.status(404).json({ error: 'Chatbot no encontrado' });
    }

    const success = await whatsappService.sendMessage(chatbotId, to, message);
    
    if (success) {
      // Guardar mensaje en base de datos
      await db.insert(whatsappMessages).values({
        id: `manual_${Date.now()}`,
        chatbotId,
        fromNumber: 'chatbot',
        toNumber: to,
        body: message,
        timestamp: new Date(),
        isFromMe: true,
        messageType: 'text'
      });

      res.json({ 
        success: true, 
        message: 'Mensaje enviado correctamente' 
      });
    } else {
      res.status(400).json({ error: 'Error enviando mensaje' });
    }

  } catch (error) {
    console.error('Error enviando mensaje:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Server-Sent Events para actualizaciones en tiempo real
router.get('/whatsapp/events/:userId', authenticateToken, (req, res) => {
  const { userId } = req.params;

  // Configurar SSE
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Cache-Control'
  });

  // Guardar conexión
  sseConnections.set(userId, res);

  // Enviar mensaje inicial
  res.write(`data: ${JSON.stringify({ type: 'connected', message: 'SSE conectado' })}\n\n`);

  // Limpiar conexión cuando se cierre
  req.on('close', () => {
    sseConnections.delete(userId);
  });
});

// Obtener historial de mensajes
router.get('/whatsapp/messages/:chatbotId', authenticateToken, async (req, res) => {
  try {
    const { chatbotId } = req.params;
    const userId = req.user.userId;

    // Verificar que el chatbot pertenece al usuario
    const chatbot = await db
      .select()
      .from(chatbots)
      .where(and(
        eq(chatbots.id, chatbotId),
        eq(chatbots.userId, userId)
      ))
      .limit(1);

    if (!chatbot[0]) {
      return res.status(404).json({ error: 'Chatbot no encontrado' });
    }

    const messages = await db
      .select()
      .from(whatsappMessages)
      .where(eq(whatsappMessages.chatbotId, chatbotId))
      .orderBy(whatsappMessages.timestamp);

    res.json({
      success: true,
      messages
    });

  } catch (error) {
    console.error('Error obteniendo mensajes:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

export default router;